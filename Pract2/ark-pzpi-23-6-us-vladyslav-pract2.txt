МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




ЗВІТ
до практичного завдання №2 з дисципліни
«Аналіз та рефакторинґ коду»
на тему: «Методи рефакторингу коду програмного забезпечення»






Виконав:                                                                                                  Перевірив:
ст. гр. ПЗПІ-23-6                       				ст. викладач катедри ПІ
Ус Владислав Миколайович			                    Сокорчук Ігор Петрович






Харків 2025
1 ІСТОРІЯ ЗМІН 

№
Дата
Версія звіту
Опис змін та виправлень
1
30.11.2025
1
Створено звіт


2 ВСТУП
     Рефакторинг коду є важливим інструментом підвищення якості програмного забезпечення, що дозволяє оптимізувати внутрішню структуру програми без зміни її зовнішньої поведінки. Систематичне вдосконалення коду сприяє покращенню читабельності, полегшує його подальшу підтримку та зменшує технічний борг, який накопичується в процесі розробки. Метою даного практичного заняття є опанування методів рефакторингу та демонстрація їх застосування на прикладах власних програмних проєктів. 
     У роботі розглядаються три методи: Replace Magic Number with Symbolic Constant, Split Temporary Variable та Hide Delegate. Їх вибір зумовлений поширеністю відповідних проблем у реальних проєктах — використанням “магічних” чисел, перевантаженими тимчасовими змінними та зайвими залежностями між класами. Для кожного методу наведено опис проблеми, аналіз недоліків вихідного фрагмента коду, результати застосованого рефакторингу та обґрунтування отриманих переваг.

3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Обрані методи рефакторингу 
     Replace Magic Number with Symbolic Constant - метод передбачає заміну неочевидних числових значень у коді на іменовані константи. Це підвищує читабельність, зменшує ризик помилок та спрощує зміну значень у майбутньому. У результаті код стає більш зрозумілим і самодокументованим.
     Split Temporary Variable - метод застосовується, коли одна тимчасова змінна використовується для кількох різних обчислень. Розділення такої змінної на окремі покращує зрозумілість коду та запобігає побічним ефектам. Це робить логіку більш передбачуваною та безпечнішою.
     Hide Delegate - метод дозволяє приховати від клієнтського коду складні ланцюжки звернень до внутрішніх об’єктів. Замість прямого доступу клієнт використовує методи-обгортки, що зменшує залежності та покращує інкапсуляцію. Такий підхід спрощує підтримку та структуру класів.
     3.2 Метод Replace Magic Number with Symbolic Constant
     Опис проблеми: У початковій версії коду використовуються числові літерали (1.2, 0.9, 0.85, 1, 2), які не мають явного смислового пояснення. Такі “магічні числа” ускладнюють розуміння бізнес-логіки, унеможливлюють швидке внесення змін та підвищують ризик помилок при модифікації коду. За відсутності іменованих констант розробник змушений щоразу згадувати або шукати, що саме означає кожне число в контексті задачі. 
1 // Приклад до рефакторингу 
2 export class PriceCalculator {
3     calculateFinalPrice(basePrice: number, customerType: number): number {
4         // 1.2 – ПДВ 20%
5         const priceWithVat = basePrice * 1.2;
6 
7         if (customerType === 1) {
8             // 0.9 – знижка 10%
9             return priceWithVat * 0.9;
10         } else if (customerType === 2) {
11             // 0.85 – знижка 15%
12             return priceWithVat * 0.85;
13         }
14 
15         return priceWithVat;
16     }
17 }
18 

      Обраний метод: Replace Magic Number with Symbolic Constant (Заміна магічних чисел символьними константами). Цей метод було використано, тому що:
* Числа представляють конкретні сутності предметної області (ставка ПДВ, розміри знижок).
* Їх значення потенційно змінні (зміна податкової ставки, маркетингових умов).
* Використання іменованих констант робить код самодокументованим і зменшує кількість прихованих знань про бізнес-логіку.
     Алгоритм проведення рефакторингу за допомогою обраного метода:
1. Виявити всі магічні числа у методі (1.2, 0.9, 0.85, 1, 2).
2. Визначити смислове значення кожного числа
3. Оголосити відповідні const або enum
4. Замінити всі входження “магічних чисел” у коді на іменовані константи.



1 // Приклад після рефакторингу 
2 export enum CustomerType {
3     Regular = 1,
4     Vip = 2,
5 }
6 
7 export class PriceCalculator {
8     private static readonly VAT_RATE = 1.2;           
9     private static readonly REGULAR_DISCOUNT = 0.9;   
10     private static readonly VIP_DISCOUNT = 0.85;      
11 
12     calculateFinalPrice(basePrice: number, customerType: CustomerType): number {
13         const priceWithVat = basePrice * PriceCalculator.VAT_RATE;
14 
15         if (customerType === CustomerType.Regular) {
16             return priceWithVat * PriceCalculator.REGULAR_DISCOUNT;
17         }
18 
19         if (customerType === CustomerType.Vip) {
20             return priceWithVat * PriceCalculator.VIP_DISCOUNT;
21         }
22 
23         return priceWithVat;
24     }
25 }
     Після застосування методу Replace Magic Number with Symbolic Constant код став значно читабельнішим, оскільки замість неочевидних числових літералів використовуються змістовні іменовані константи та значення enum, що полегшує розуміння логіки розрахунків. Внесення змін також спростилося: при зміні ставки ПДВ або розмірів знижок достатньо відредагувати значення констант в одному місці, не виконуючи пошук по всьому коді. Це зменшує ризик помилок і виключає ситуації, коли одна й та сама сутність може бути представлена різними числами у різних частинах програми. Крім того, код став ближчим до предметної області, оскільки назви констант та enum чітко відображають бізнес-поняття, що позитивно впливає на подальшу підтримку й розширення рішення.
     3.3 Метод Split Temporary Variable
	Опис проблеми: У вихідному коді одна тимчасова змінна використовується для різних проміжних обчислень. Це створює неочевидні зв’язки та ускладнює розуміння логіки, оскільки змінна змінює своє призначення в процесі виконання методу. Подібний підхід підвищує ризик помилок, особливо якщо логіка стає складнішою, або змінна використовується у різних гілках обчислень. Код стає менш зрозумілим та важчим у підтримці.
1 // Приклад до рефакторингу 
2 export class OrderService {
3     calculateDeliveryCost(weight: number, distance: number): number {
4         let result = weight * 2; // базова вартість залежно від ваги
5         result = result + distance * 0.5; // додається вартість за відстань
6         return result;
7     }
8 }
9     }
10 }
     Обраний метод: Split Temporary Variable. Розглянемо причини використання цього методу:
* Одна змінна не повинна виконувати кілька ролей — це порушує принципи чистого коду.
* Код стає важче читати та модифікувати, коли значення змінної змінюється на зовсім інше.
* Окремі змінні для кожного обчислення роблять логіку менш помилковою та більш передбачуваною.
     Алгоритм проведення рефакторингу за допомогою обраного метода:
1. Проаналізувати, де змінна використовується для різних сутностей і виділити різні етапи обчислень.
2. Створити окремі названі змінні для кожного етапу(weightCost, distanceCost).
3. Замінити повторне присвоєння однієї змінної на чисте поетапне обчислення.

1 // Після рефакторингу 
2 export class OrderService {
3     calculateDeliveryCost(weight: number, distance: number): number {
4         const weightCost = weight * 2;     // вартість за вагу
5         const distanceCost = distance * 0.5;  // вартість за відстань
6         return weightCost + distanceCost;
7     }
8 }

     Після застосування методу Split Temporary Variable код став значно зрозумілішим, оскільки кожна змінна тепер виконує одну чітку роль, а логіка обчислень розділена на окремі етапи. Завдяки цьому зменшується ризик помилок, пов’язаних із повторним використанням однієї й тієї самої змінної для різних цілей. Код став простішим у читанні та підтримці, а назви змінних (weightCost, distanceCost) безпосередньо відображають специфіку бізнес-логіки, що позитивно впливає на подальше розширення та модифікацію функціоналу.
     3.3 Метод Hide Delegate
     	Опис проблеми: У вихідному коді клієнтський клас напряму взаємодіє з внутрішньою структурою іншого об’єкта через ланцюжок звернень. Будь-яка зміна внутрішньої структури Department або Manager потребує змін у всіх клієнтах. Код стає важчим у підтримці.
1 // До рефакторингу (TypeScript)
2 
3 export class Manager {
4     constructor(public name: string) {}
5 }
6 
7 export class Department {
8     constructor(public manager: Manager) {}
9 }
10 
11 export class Employee {
12     constructor(public department: Department) {}
13 
14     getManagerName(): string {
15         return this.department.manager.name;
16     }
17 }
     Обрано метод Hide Delegate, бо:
* Зменшує залежність класу Employee від деталей реалізації Department. 
* Клієнт має отримувати потрібні дані, не знаючи, як саме вони витягуються. 
* Покращує інкапсуляцію та робить код стійкішим до змін.
Алгоритм проведення рефакторингу:
1. Визначити місце, де клієнтський код використовує делегата (department.manager.name). 
2. Додати у клас Department метод, який повертає потрібні дані (getManagerName()). 
3. Замінити звернення до ланцюжка .department.manager.name на виклик нового методу.


1 // Після рефакторингу 
2 
3 export class Manager {
4     constructor(private name: string) {}
5 
6     getName(): string {
7         return this.name;
8     }
9 }
10 
11 export class Department {
12     constructor(private manager: Manager) {}
13 
14     getManagerName(): string {
15         return this.manager.getName();
16     }
17 }
18 
19 export class Employee {
20     constructor(private department: Department) {}
21 
22     getManagerName(): string {
23         return this.department.getManagerName();
24     }
25 }
     Після застосування методу Hide Delegate клас Employee більше не залежить від того, як саме влаштований Department або як зберігається інформація про менеджера. Це значно покращило інкапсуляцію: зміна внутрішньої структури департаменту тепер не потребуватиме змін у клієнтському коді. Логіка стала більш стійкою до майбутніх модифікацій, а код — легшим для розширення і підтримки. Завдяки виділеним методам (getManagerName()) інтерфейс класів став чіткішим, а бізнес-логіка зрозумілішою.


ВИСНОВКИ
     У ході виконання практичного заняття було розглянуто та проаналізовано три ключові методи рефакторингу, описані Мартіном Фаулером: Replace Magic Number with Symbolic Constant, Split Temporary Variable та Hide Delegate. На основі реальних фрагментів коду було продемонстровано типові проблеми, що виникають у програмних проєктах під час росту складності та накопичення технічного боргу. 
     Отримано практичні навички виявлення недоліків у структурі коду та застосування відповідних методів рефакторингу для підвищення його якості. Здійснений рефакторинг дозволив покращити читабельність, зменшити зв’язність між компонентами, підвищити передбачуваність логіки та забезпечити легшу підтримку коду надалі. Робота підтвердила важливість застосування систематичних підходів до удосконалення існуючих програмних рішень і продемонструвала, що правильний вибір методу рефакторингу дозволяє покращити внутрішній дизайн без зміни зовнішньої поведінки програмного забезпечення.


ВИКОРИСТАНІ ДЖЕРЕЛА
1. Design Patterns and Refactoring. Design Patterns & Refactoring. URL: https://sourcemaking.com/refactoring (дата звернення: 30.11.2025).
2. Fowler M. Refactoring: Improving the Design of Existing Code. URL: https://martinfowler.com/books/refactoring.html (дата звернення: 30.11.2025).
3. Martin R. C. Clean Code: A Handbook of Agile Software Craftsmanship. URL: https://github.com/Gatjuat-Wicteat-Riek/clean-code-book (дата звернення: 30.11.2025).


ДОДАТОК А
Відеозапис


Відеозапис доповіді: https://youtu.be/BCMJBkJFUt8

Хронологічний опис відеозапису:
00:00 - Вступ 
00:19 - Методи рефакторингу 
00:58 - Replace Magic Number with Symbolic Constant 
03:01 - Split Temporary Variable 
04:28 - Hide Delegate 
05:57 - Висновки 
06:51 - Джерела


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд 


Рисунок Б.2 – Методи для розглядання


Рисунок Б.3 – Replace Magic Number with Symbolic Constant(опис, причини, переваги)


Рисунок Б.4 – Replace Magic Number with Symbolic Constant(алгоритм)






Рисунок Б.5 – Replace Magic Number with Symbolic Constant(приклади)


Рисунок Б.6 – Split Temporary Variable(опис, причини, переваги, алгоритм)



Рисунок Б.7 – Split Temporary Variable(приклади)


Рисунок Б.8 – Hide Delegate(опис, причини, переваги)


Рисунок Б.9 – Hide Delegate(алгоритм)


Рисунок Б.10 – Hide Delegate(приклади)


Рисунок Б.11 – Висновки


Рисунок Б.12 – Використані джерела
2


